import path from 'node:path';
import type { Props } from 'bluebun';
import prettier from 'prettier';

interface BuildProps extends Props {
  options: {
    /** Path of json file with svg data */
    input: string;
    /** Where to output the generated icons file */
    output: string;
  };
}

type IconData = {
  [iconName: string]: {
    label: string;
    svg: SvgData;
    styles: string[];
  };
};

type SvgData = {
  [iconType: string]: {
    height: number;
    width: number;
    last_modified: number;
    path: string | string[];
    viewBox: [number, number, number, number];
  };
};

async function prettifyTs(content: string) {
  return prettier.format(content, {
    parser: 'typescript',
    tabWidth: 2,
    useTabs: false,
  });
}

const iconTypesToFilter = ['solid', 'regular'];

function isIconWeWant(styles: string[]) {
  const value = iconTypesToFilter.every((style) => styles.includes(style));
  return value;
}

function getPathContent(path: string) {
  return `<path fill="currentColor" d="${path}" />`;
}

function asUnion(items: string[]) {
  return items.map((item) => `'${item}'`).join(' | ');
}

export default {
  name: 'build',
  description: 'ðŸš€ Build',
  run: async (props: BuildProps) => {
    const { input, output } = props.options;
    if (!input) {
      console.error('Input file is required. Use --input to specify the file.');
      process.exitCode = 1;
      return;
    }
    if (!output) {
      console.error(
        'Output directory is required. Use --output to specify the directory.',
      );
      process.exitCode = 1;
      return;
    }

    const cwd = Bun.env.PWD;
    const components: string[] = [];
    const iconNames: string[] = [];

    const inputPath = input.startsWith('.')
      ? path.resolve(cwd, input)
      : require.resolve(input);

    const outputPath = output?.startsWith('.') ? `${cwd}/${output}` : output;

    const jsonData = (await Bun.file(inputPath).json()) as IconData;

    for (const [iconName, iconData] of Object.entries(jsonData)) {
      if (isIconWeWant(iconData.styles)) {
        const variantsContent: string[] = [];

        const splitName = iconName.split('-');
        const pascalCaseName = splitName
          .map((name) => name.charAt(0).toUpperCase() + name.slice(1))
          .join('');

        const iconsToIgnore = ['42Group', '500px'];
        if (iconsToIgnore.includes(pascalCaseName)) continue;

        const componentName =
          {
            '0': 'Zero',
            '00': 'DoubleZero',
            '1': 'One',
            '2': 'Two',
            '3': 'Three',
            '4': 'Four',
            '5': 'Five',
            '6': 'Six',
            '7': 'Seven',
            '8': 'Eight',
            '9': 'Nine',
            Map: 'TravelMap',
            Function: 'CodeFunction',
            Infinity: 'NumberInfinity',
            '360Degrees': 'Degrees360',
          }[pascalCaseName] ?? pascalCaseName;

        iconNames.push(componentName);

        let viewBox = '';
        // biome-ignore lint/correctness/noUnusedVariables: it's used in for loop
        let width = '';
        // biome-ignore lint/correctness/noUnusedVariables: it's used in for loop
        let height = '';

        for (const [variant, svgData] of Object.entries(iconData.svg)) {
          if (iconTypesToFilter.includes(variant)) {
            viewBox = `${svgData.viewBox[0]} ${svgData.viewBox[1]} ${svgData.viewBox[2]} ${svgData.viewBox[3]}`;
            width = `${svgData.width}`;
            height = `${svgData.height}`;

            let pathContent = '';

            if (typeof svgData.path === 'string') {
              pathContent = getPathContent(svgData.path);
            } else {
              pathContent = `<>${svgData.path
                .map(getPathContent)
                .join('\n')}</>`;
            }

            const variantContent = `
    if (variant === '${variant}') {
      svgPath = ${pathContent}
    }
    `;
            variantsContent.push(variantContent);
          }
        }
        const componentContent = `
  export const ${componentName} = ({ ref, variant, width, height, ...props }: SvgIconProps ) => {
    let svgPath: React.ReactNode;

    ${variantsContent.join('\n')}

    return (
      <svg ref={ref} viewBox="${viewBox}" width={width} height={height} {...props}>
        <title>${iconData.label}</title>
        {svgPath}
      </svg>
    )
  };

  `;
        components.push(componentContent);
      }
    }

    const content = `
/**
* ------------------- GENERATED | DO NOT MODIFY THIS FILE ---------------------
* This file is generated by icons svg CLI command.
*/

export interface SvgIconProps extends React.ComponentPropsWithRef<"svg"> {
  variant: IconVariant;
};

export type IconVariant = ${asUnion(iconTypesToFilter)};

export type IconName = ${asUnion(iconNames)};

${components.join('\n')}
`;

    await Bun.write(`${outputPath}`, await prettifyTs(content));
  },
};
